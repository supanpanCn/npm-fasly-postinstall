// only 'yarn add' will trigger the 'preinstall' hook
function yarn(ctx) {
  return function () {
    const { server, npm } = ctx.config;
    const { diffPkg, exit, log, checkInstalledModule } = ctx.utils;
    const { copy, exists, readJson, writeJson } = ctx.fs;
    const { resolves } = ctx.const;
    const installed = checkInstalledModule(true);
    if (server === "install") {
      if (npm.name === "yarn") {
        if (installed) {
          const puts = diffPkg();
          log("UN_MATCHED_INSTALL", puts);
          const pkg_path = resolves.get("pkg_path");
          const copy_pkg_path = resolves.get("copy_path");
          if (exists(copy_pkg_path) && exists(pkg_path)) {
            const o = readJson(copy_pkg_path);
            const l = readJson(pkg_path);
            writeJson(
              copy_pkg_path,
              {
                ...o,
                ...l,
                dependencies: o.dependencies || {},
                devDependencies: o.devDependencies || {},
              },
              {
                spaces: "\t",
              }
            );
            copy(copy_pkg_path, pkg_path);
          }
          exit();
        }
      }
    }
    return installed;
  };
}

// no lock file is generated by 'cnpm'
function cnpm(ctx) {
  return function (puts) {
    const { exists } = ctx.fs;
    const { resolves, PMs } = ctx.const;
    const { PM } = ctx.config;
    const { log , exit } = ctx.utils;
    const checks = PMs.filter((v) => v !== "cnpm");
    let gus = [];
    for (let i = 0; i < checks.length; i++) {
      const path = resolves.get("lock_path")(checks[i]);
      if (exists(path)) {
        gus.push(checks[i]);
      }
    }
    gus = gus.filter((v) => v !== PM);
    if (gus.length) {
      log("UN_MATCHED_INSTALL", puts);
      log("GUIDE", "yellow");
      exit()
    }
  };
}
module.exports = {
  yarn,
  cnpm,
};
